---
layout: post
title:  C语言问题集
tags: [C]
---

###0.指针自增问题
> - *p++ == *(p++)  因为一元操作符*和++都是从又到左运算。
> - p和p++的输出结果表示位置，跟系统有关，相差为4，因为系统int为4个字节。

看下面这个程序的输出：

```c
#include <stdio.h>
main()
{
  int a=2,*p=&a,*q=&a;
  printf("%d %d/n",*p++,*(q++));
  p=&a;
  q=&a;
  printf("%d %d/n",*p,(*q)++);

}
```

上面程序输出如下:
> 2 2

> 2 2

C语言的18个经典问题


###1.这样的初始化有什么问题？char *p = malloc(10); 编译器提示“非法初始式” 云云。

答:这个声明是静态或非局部变量吗？函数调用只能出现在自动变量(即局部非静态变量) 的初始式中。
因为静态变量的地址必须在编译的过程中就确定下来而malloc()申请的内存地址是在运行时确定的。
###2.*p++ 自增p 还是p 所指向的变量?

答:后缀++ 和-- 操作符本质上比前缀一目操作的优先级高, 因此*p++ 和*(p++) 等价, 它自增p 并返回p 自增之前所指向的值。
要自增p 指向的值, 使用(*p)++, 如果副作用的顺序无关紧要也可以使用++*p。


### 3. 我有一个char * 型指针正巧指向一些int 型变量, 我想跳过它们。为什么如下的代码((int *)p)++; 不行?

答:在C 语言中, 类型转换意味着“把这些二进制位看作另一种类型, 并作相应的对待”; 这是一个转换操作符,  根据定义它只能生成一个右值(rvalue)。而右值既不能赋值, 也不能用++ 自增。(如果编译器支持这样的扩展,  那要么是一个错误, 要么是有意作出的非标准扩展。) 要达到你的目的可以用:p = (char *)((int *)p + 1);或者,因为p 是char * 型, 直接用p += sizeof(int);


### 4.空指针和未初始化的指针是一回事吗?

答:空指针在概念上不同于未初始化的指针:空指针可以确保不指向任何对象或函数;而未初始化指针则可能指向任何地方。


### 5.我可以用0来表示空指针吗?

答:根据语言定义, 在指针上下文中的常数0 会在编译时转换为空指针。也就是说, 在初始化、赋值或比较的时候,  如果一边是指针类型的值或表达式, 编译器可以确定另一边的常数0 为空指针并生成正确的空指针值。因此下边的代码段完全合法：

char *p = 0;

if(p != 0)

然而, 传入函数的参数不一定被当作指针环境, 因而编译器可能不能识别未加修饰的0 “表示” 指针。在函数调用的上下文中生成空指针需要明确的类型转换,强制把0 看作指针。
例如, Unix 系统调用execl 接受变长的以空指针结束的字符指针参数。它应该如下正确调用：
execl("/bin/sh", "sh", "-c", "date", (char *)0);
如果省略最后一个参数的(char *) 转换, 则编译器无从知道这是一个空指针,从而当作一个0 传入。(注意很多Unix 手册在这个例子上都弄错了。)
有两条简单规则你必须遵循:
1. 当你在源码中需要空指针常数时, 用“0” 或“NULL”。
2. 如果在函数调用中“0” 或“NULL” 用作参数, 把它转换成被调函数需要的指针类型


### 6. 既然数组引用会蜕化为指针, 如果arr 是数组, 那么arr 和&arr 又有什么区别呢?

答:区别在于类型:
在标准C 中, &arr 生成一个“T 型数组” 的指针, 指向整个数组。
在所有的C 编译器中, 对数组的简单引用(不包括& 操作符)生成一个T 的指针类型的指针, 指向数组的第一成员。


### 7. 我如何声明一个数组指针?

答:通常, 你不需要。当人们随便提到数组指针的时候, 他们通常想的是指向它的第一个元素的指针。
考虑使用指向数组某个元素的指针, 而不是数组的指针。类型T 的数组蜕变成类型T 的指针, 这很方便;  在结果的指针上使用下标或增量就可以访问数组中单独的成员。而真正的数组指针, 在使用下标或增量时, 会跳过整个数组,  通常只在操作数组的数组时有用—— 如果还有一点用的话。如果你真的需要声明指向整个数组的指针,  使用类似“int (*ap)[N];”这样的声明。其中N 是数组的大小。如果数组的大小未知, 原则上可以省略N, 但是这样生成的类型,  “指向大小未知的数组的指针”, 毫无用处。


### 8. 当我向一个接受指针的指针的函数传入二维数组的时候, 编译器报错了,这是怎么回事?

答:数组蜕化为指针的规则不能递归应用。数组的数组 (即C 语言中的二维数组) 蜕化为数组的指针, 而不是指针的指针。
数组指针常常令人困惑, 需要小心对待; 如果你向函数传递二位数组:

int array[NROWS][NCOLUMNS];

f(array);

那么函数的声明必须匹配:

void f(int a[][NCOLUMNS])

{ ... }

或者

void f(int (*ap)[NCOLUMNS]) /* ap 是个数组指针*/

{ ... }

在第一个声明中, 编译器进行了通常的从“数组的数组” 到“数组的指针” 的隐式转换; 第二种形式中的指针定义显而易见。

因为被调函数并不为数组分配地址,所以它并不需要知道总的大小,所以行数NROWS可以省略。但数组的宽度依然重要,所以列维度NCOLUMNS(对于三维或多维数组,相关的维度)必须保留。

如果一个函数已经定义为接受指针的指针, 那么几乎可以肯定直接向它传入二维数组毫无意义。


### 9. 我的strcat() 不行.我试了char *s1 = "Hello, "; char *s2 = "world!";  char *s3 = strcat(s1, s2); 但是我得到了奇怪的结果。

答:这里主要的问题是没有正确地为连接结果分配空间。C 没有提供自动管理的字符串类型。C 编译器只为源码中明确提到的对象分配空间(对于字符串, 这包括字符数组和串常量)。

程序员必须为字符串连接这样的运行期操作的结果分配足够的空间,可以通过声明数组或调用malloc() 完成。strcat() 不进行任何分配;

第二个串原样不动地附加在第一个之后。

因此, 一种解决办法是把第一个串声明为数组:

char s1[20] = "Hello, ";

由于strcat() 返回第一个参数的值, 本例中为s1, s3 实际上是多余的; 在strcat() 调用之后, s1 包含结果。

提问中的strcat() 调用实际上有两个问题: s1 指向的字符串常数, 除了空间不足以放入连接的字符串之外,  甚至都不一定可写。


### 10. 那么返回字符串或其它集合的正确方法是什么呢?

答:返回指针必须是静态分配的缓冲区, 或者调用者传入的缓冲区,  或者用 malloc() 获得的内存, 但不能是局部(自动) 数组。


### 11. 我有个程序分配了大量的内存, 然后又释放了。但是从操作系统看,内存的占用率却并没有回去。

答:多数malloc/free 的实现并不把释放的内存返回操作系统, 而是留着供同一程序的后续malloc() 使用。


### 12. calloc() 和malloc() 有什么区别?利用calloc 的零填充功能安全吗?free() 可以释放calloc() 分配的内存吗, 还是需要一个cfree()?

答:calloc(m, n) 本质上等价于:
p = malloc(m * n);
memset(p, 0, m * n);
填充的零是全零, 因此不能确保生成有用的空指针值或浮点零值free()  
可以安全地用来释放calloc() 分配的内存。


### 13. 我认为我的编译器有问题: 我注意到sizeof('a') 是2 而不是1 (即,不是sizeof(char))。

答:可能有些令人吃惊, C语言中的字符常数是int 型, 因此sizeof('a') 是sizeof(int),这是另一个与C++ 不同的地方。


### 14. 为什么声明extern int f(struct x *p); 报出了一个奇怪的警告信息“结构x 在参数列表中声明”?

答:与C 语言通常的作用范围规则大相径庭的是,在原型中第一次声明(甚至提到)的结构不能和同一源文件中的其它结构兼容,它在原型的结束出就超出了作用范围。

要解决这个问题,在同一源文件的原型之前放上这样的声明:struct x;

它在文件范围内提供了一个不完整的结构x的声明,这样,后续的用到结构x的声明至少能够确定它们引用的是同一个结构x。


### 15. 我不明白为什么我不能像这样在初始化和数组维度中使用常量:const int n = 5; int a[n];

答:const 限定词真正的含义是 “只读的”; 用它限定的对象是运行时 (同常) 不能被赋值的对象。因此用 const 限定的对象的值并不完全是一个真正的常量。在这点上 C 和 C++ 不一样。如果你需要真正的运行时常量, 使用预定义宏 #define(或enum)。

### 16. 我能否把 main() 定义为 void, 以避免扰人的 “main无返回值”警告?

答: 不能。main() 必须声明为返回 int, 且没有参数或者接受适当类型的两个参数。如果你调用了 exit() 但还是有警告信息, 你可能需要插入一条冗余的 return语句(或者使用某种 “未到达”指令, 如果有的话）。

很多书不负责任地在例子中使用 void main(),  并宣称这样是正确的。但他们错了。


### 17. #pragma 是什么, 有什么用？

答:#pragam 指令提供了一种单一的明确定义的 “救生舱”, 可以用作各种 (不可移植的) 实现相关的控制和扩展:源码表控制、结构压缩、警告去除 (就像 lint 的老 /* NOTREACHED */注释), 等等。


### 18. “#pragma once” 是什么意思?我在一些头文件中看到了它。

答:这是某些预处理器实现的扩展用于使头文件自我识别; 它跟#ifndef技巧等价, 不过移植性差些。
